// In this example we execute a contract funciton exported as "_call"

extern crate wasmi;
extern crate wabt;

use std::env::args;
use std::fs::File;
//use wasmi::{
//    ModuleInstance, NopExternals, RuntimeArgs, RuntimeValue, ImportsBuilder,
//    Externals, Trap, Signature};

use wasmi::{
	Error as InterpreterError, NopExternals, ModuleInstance, ModuleRef,
	Externals, RuntimeValue, FuncRef, ModuleImportResolver,
	FuncInstance, HostError, ImportsBuilder, Signature, ValueType,
	RuntimeArgs, Trap,
};

fn main() {
    let args: Vec<_> = args().collect();
    if args.len() != 3 {
        println!("Usage: {} <wasm file> <arg>", args[0]);
        println!("    wasm file should contain exported `_call` function with single I32 argument");
        return;
    }

    // Here we load module using dedicated for this purpose
    // `load_from_file` function (which works only with modules)
    use std::io::prelude::*;
    let mut file = File::open(&args[1]).unwrap();
    let mut buf = Vec::new();
    file.read_to_end(&mut buf).unwrap();
    let module = wasmi::Module::from_buffer(buf).unwrap();

    // Intialize deserialized module. It adds module into It expects 3 parameters:
     // - a name for the module
     // - a module declaration
     // - "main" module doesn't import native module(s) this is why we don't need to provide external native modules here
     // This test shows how to implement native module https://github.com/NikVolf/parity-wasm/blob/master/src/interpreter/tests/basics.rs#L197

     struct Runtime {
    	//player: tictactoe::Player,
    	//game: &'a mut tictactoe::Game,
    }

    const SET_FUNC_INDEX: usize = 0;
    const GET_FUNC_INDEX: usize = 1;
    const PRINT_FUNC_INDEX: usize = 2;

    impl Externals for Runtime {
    	fn invoke_index(
    		&mut self,
    		index: usize,
    		args: RuntimeArgs,
    	) -> Result<Option<RuntimeValue>, Trap> {
    		match index {
    			SET_FUNC_INDEX => {
    				let idx: i32 = args.nth(0);
    				//self.game.set(idx, self.player)?;
    				Ok(None)
    			}
    			GET_FUNC_INDEX => {
    				let idx: i32 = args.nth(0);
    				//let val: i32 = //tictactoe::Player::into_i32(self.game.get(idx)?);
    				Ok(Some(wasmi::RuntimeValue::I32(0)))
    			}
                PRINT_FUNC_INDEX => {
                    let string: u32 = args.nth(0);
                    println!("{:?}", string);
                    Ok(None)
                }
    			_ => panic!("unknown function index")
    		}
    	}
    }

    struct RuntimeModuleImportResolver;

    impl ModuleImportResolver for RuntimeModuleImportResolver {
    	fn resolve_func(
    		&self,
    		field_name: &str,
    		_signature: &Signature,
    	) -> Result<FuncRef, InterpreterError> {
    		let func_ref = match field_name {
    			"set" => {
    				FuncInstance::alloc_host(Signature::new(&[ValueType::I32][..], None), SET_FUNC_INDEX)
    			},
    			"get" => {
                    FuncInstance::alloc_host(Signature::new(&[ValueType::I32][..], Some(ValueType::I32)), GET_FUNC_INDEX)
                },
                "print" => {
    				FuncInstance::alloc_host(Signature::new(&[ValueType::I32][..], None), PRINT_FUNC_INDEX)
    			},
                _ => return Err(
                    InterpreterError::Function(
                        format!("host module doesn't export function with name {}", field_name)
                    )
                )
    		};
    		Ok(func_ref)
    	}
    }

    let mut imports = ImportsBuilder::new();
    imports.push_resolver("env", &RuntimeModuleImportResolver);

    let main = ModuleInstance::new(&module, &imports)
        .expect("Failed to instantiate module")
        .assert_no_start();
        //.expect("Failed to run start function in module");
        //.run_start(&mut NopExternals)

    let memory = main
			.export_by_name("memory")
			.expect("all modules compiled with rustc should have an export named 'memory'; qed")
			.as_memory()
			.expect("in module generated by rustc export named 'memory' should be a memory; qed")
			.clone();

    memory.set(0, &vec![6u8,7u8,8u8]);

    // The argument should be parsable as a valid integer
    let argument: i32 = args[2].parse().expect("Integer argument required");
    let mut runtime = Runtime{};
    // "_call" export of function to be executed with an i32 argument and prints the result of execution
    //println!("Result: {:?}", main.invoke_export("_call", &[RuntimeValue::I32(argument)], &mut runtime));
    println!("Result: {:?}", main.invoke_export("_call", &[RuntimeValue::I32(0 as i32), RuntimeValue::I32(3 as i32)], &mut runtime));
}
