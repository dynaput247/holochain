
use holochain_wasm_utils::SinglePageAllocation;
use holochain_wasm_utils::SinglePageStack;

use wasmi::{
  MemoryRef, ModuleRef,
};


//--------------------------------------------------------------------------------------------------
// WASM Memory Manager
//--------------------------------------------------------------------------------------------------

#[derive(Clone, Debug)]
pub struct SinglePageManager {
  stack: SinglePageStack,
  wasm_memory: MemoryRef,
  // allocations : Vec<MemoryAllocation> // for debugging only?
}

impl SinglePageManager {

  pub fn new(wasm_instance : ModuleRef) -> Self
  {
    // get wasm memory reference from module
    let wasm_memory = wasm_instance
      .export_by_name("memory")
      .expect("all modules compiled with rustc should have an export named 'memory'; qed")
      .as_memory()
      .expect("in module generated by rustc export named 'memory' should be a memory; qed")
      .clone();

    return SinglePageManager {
      stack: SinglePageStack::default(),
      wasm_memory : wasm_memory.clone(),
      // allocations : Vec::new(),
    };
  }

  pub fn allocate(&mut self, size: u16) -> Result<SinglePageAllocation, &str> {
    if self.stack.top() as u32 + size as u32 >= 65536 {
      return Err("Out of memory");
    }
    let offset = self.stack.allocate(size);
    let allocation = SinglePageAllocation { offset: offset, length: size};
    // self.allocations.push(allocation);
    Ok(allocation)
  }


  pub fn malloc(&mut self, size: u16) -> Result<u16, &str> {
    let res = self.allocate(size);
    if let Ok(mem_buf) = res {
      return Ok(mem_buf.offset);
    }
    Err("out of memory")
  }


  /// Write data on stack
  pub fn write(&mut self, data : Vec<u8>) -> Result<SinglePageAllocation, &str> {
    let data_len = data.len();
    if data_len > 65536 {
      return Err("data length provided is bigger than 64KiB")
    }

    // scope for mutable borrow of self
    let mem_buf: SinglePageAllocation;
    {
      let res = self.allocate(data_len as u16);
      if res.is_err() {
        return Err("Not enough free memory available");
      }
      mem_buf = res.unwrap();
    }

    self.wasm_memory
      .set(mem_buf.offset as u32, &data)
      .expect("memory should be writable");
    Ok(mem_buf)
  }


  // MemoryAllocation is garanteed to be valid (does not overflow page size)
  pub fn read(&self, allocation : &SinglePageAllocation) -> Vec<u8> {
    return
      self.wasm_memory
      .get(allocation.offset as u32, allocation.length as usize)
      .expect("Successfully retrieve the result")
  }

//  pub fn free(&mut self) {
//    // TODO
//  }

}